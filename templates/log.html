<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>å®æ—¶æ—¥å¿—</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        body {
            background: black;
            color: #00FF00;
            font-family: 'Poppins', sans-serif;
            margin: 0;
            padding: 0;
        }
        #output {
            margin: 0;
            padding: 10px;
            overflow-y: auto;
            height: calc(100vh - 40px); /* å‡å»æŒ‰é’®çš„é«˜åº¦ */
            box-sizing: border-box;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        #downloadBtn {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            background-color: #222;
            color: #0f0;
            border: none;
            padding: 10px;
            font-size: 16px;
            cursor: pointer;
            z-index: 999;
        }
    </style>
</head>
<body>

    <pre id="output"></pre>
    <button id="downloadBtn">ğŸ“¥ ä¸‹è½½æ—¥å¿—ä¸º .log æ–‡ä»¶</button>

    <script src="https://cdn.socket.io/4.3.2/socket.io.min.js"></script> 
    <script>
        const MAX_LINES = 500;

        function scrollToBottom() {
            const output = document.getElementById("output");
            output.scrollTop = output.scrollHeight;
        }

        function limitLines(element, maxLines) {
            const lines = element.innerHTML.split('\n');
            if (lines.length > maxLines) {
                element.innerHTML = lines.slice(-maxLines).join('\n');
            }
        }

        function downloadLog() {
            const output = document.getElementById("output");
            const blob = new Blob([output.textContent], { type: 'text/plain' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = 'logfile.log';
            a.click();
            URL.revokeObjectURL(a.href);
        }

        // ANSIé¢œè‰²ç æ˜ å°„åˆ°CSSé¢œè‰²ï¼Œæ”¯æŒ8/16è‰²å’Œ24ä½çœŸå½©è‰²
        const ansiColorMap = {
            30: '#000', 31: '#f00', 32: '#0f0', 33: '#ff0',
            34: '#00f', 35: '#f0f', 36: '#0ff', 37: '#fff',
            90: '#888', 91: '#f88', 92: '#8f8', 93: '#ff8',
            94: '#88f', 95: '#f8f', 96: '#8ff', 97: '#eee'
        };
        // è§£æANSIè½¬ä¹‰åºåˆ—å¹¶æŸ“è‰²ï¼Œæ”¯æŒ24ä½çœŸå½©è‰²
        function ansiToHtml(str) {
            // å…ˆè½¬ä¹‰HTML
            str = str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
            // å¤„ç†\tå¯è§åŒ–ï¼ˆå¯é€‰ï¼‰
            str = str.replace(/\t/g, '<span style="color:#888">    </span>');
            let openTags = [];
            // å¤„ç†24ä½çœŸå½©è‰²å’Œæ™®é€šé¢œè‰²
            str = str.replace(/\x1b\[([0-9;]*)m/g, function(_, code) {
                if (!code) code = '0';
                let codes = code.split(';').map(Number);
                let html = '';
                let i = 0;
                while (i < codes.length) {
                    let c = codes[i];
                    if (c === 0) { // é‡ç½®
                        while(openTags.length) html += '</span>', openTags.pop();
                        i++;
                    } else if (c === 1) { // ç²—ä½“
                        html += '<span style="font-weight:bold">';
                        openTags.push('bold');
                        i++;
                    } else if (c === 4) { // ä¸‹åˆ’çº¿
                        html += '<span style="text-decoration:underline">';
                        openTags.push('underline');
                        i++;
                    } else if (c === 22) { // å…³é—­ç²—ä½“
                        while(openTags.length && openTags[openTags.length-1]==='bold') html += '</span>', openTags.pop();
                        i++;
                    } else if (c === 24) { // å…³é—­ä¸‹åˆ’çº¿
                        while(openTags.length && openTags[openTags.length-1]==='underline') html += '</span>', openTags.pop();
                        i++;
                    } else if (c === 39) { // é»˜è®¤å‰æ™¯è‰²
                        while(openTags.length && openTags[openTags.length-1]==='color') html += '</span>', openTags.pop();
                        i++;
                    } else if (c === 38 && codes[i+1] === 2) { // 24ä½çœŸå½©è‰²å‰æ™¯
                        let r = codes[i+2], g = codes[i+3], b = codes[i+4];
                        html += `<span style="color:rgb(${r},${g},${b})">`;
                        openTags.push('color');
                        i += 5;
                    } else if (ansiColorMap[c]) { // 8/16è‰²
                        html += `<span style="color:${ansiColorMap[c]}">`;
                        openTags.push('color');
                        i++;
                    } else {
                        i++;
                    }
                }
                return html;
            });
            // å…³é—­æ‰€æœ‰æœªé—­åˆæ ‡ç­¾
            while(openTags.length) str += '</span>', openTags.pop();
            // æ¢å¤æ­£å¸¸æ¢è¡Œ
            str = str.replace(/\r/g, '');
            str = str.replace(/\n/g, '\n'); // è®©preæ ‡ç­¾è‡ªåŠ¨æ¢è¡Œ
            return str;
        }

        // åˆå§‹åŒ– socket.io è¿æ¥
        const socket = io();

        socket.on('connect', () => {
            console.log('Connected to server');
            socket.emit('request_history');
        });

        socket.on('history', (msg) => {
            const output = document.getElementById("output");
            output.innerHTML = ansiToHtml(msg.data);
            limitLines(output, MAX_LINES);
            scrollToBottom();
        });

        socket.on('command_output', (msg) => {
            const output = document.getElementById("output");
            output.innerHTML += ansiToHtml(msg.data);
            limitLines(output, MAX_LINES);
            scrollToBottom();
        });

        // ç»‘å®šä¸‹è½½æŒ‰é’®ç‚¹å‡»äº‹ä»¶
        document.getElementById('downloadBtn').addEventListener('click', downloadLog);
    </script>
</body>
</html>